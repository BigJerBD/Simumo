let olMap;
let olVisualizationLayer;

(function(win, doc) {

  let olview = new ol.View({
      center: [0, 0],
      zoom: 3,
      minZoom: 13,
      maxZoom: 20
    }),
    baseLayer = new ol.layer.Tile({
      source: new ol.source.OSM()
    }),
    map = new ol.Map({
      target: doc.getElementById('map'),
      view: olview,
      layers: [baseLayer]
    }),
    popup = new ol.Overlay.Popup();

  olMap = map; //keep access to map variable

  //Instantiate with some options and add the Control
  let geocoder = new Geocoder('nominatim', {
    provider: 'osm',
    targetType: 'glass-button',
    lang: 'en',
    placeholder: 'Search for ...',
    limit: 5,
    keepOpen: false,
    initialLocation: {{initialLocation}}
  });

  map.addControl(geocoder);
  map.addOverlay(popup);

  //Reveal text label specifying the exact value of circle features when the mouse is on it
  map.on('pointermove', function(e) {
    //Remove the text label of the circle features that were clicked on before
    if(olVisualizationLayer)
    {
      let features = olVisualizationLayer.getSource().getFeatures();
      features.forEach(function(entry) {
        entry.getStyle().setText('');
      });

      //Add text label style for the feature where the mouse is to add the exact value
      map.forEachFeatureAtPixel(e.pixel, function(feature) {
        if(feature.get("value") != null)
        {
          feature.getStyle().setText(new ol.style.Text({
            font: 'bold 14px Arial',
            text: (Math.round(feature.get("unormalizedValue") * 10) / 10).toString(),
            fill: new ol.style.Fill({color: 'black'}),
            offsetY: -15
          }));
        }
      });
      olVisualizationLayer.getSource().refresh({force:true}); //refresh the layer for the new styles
    }});
})(window, document);


function getColor(color1, color2, interpolation)
{
  let diffR = color2.r - color1.r;
  let diffG = color2.g - color1.g;
  let diffB = color2.b - color1.b;
  return {
    r: color1.r + interpolation * diffR,
    g: color1.g + interpolation * diffG,
    b: color1.b + interpolation * diffB
  };
}

function getColorFromGradient(gradient, interpolation)
{
  if(interpolation == 0)
  {
    return gradient[0];
  }
  else if(interpolation == 1)
  {
    return gradient[gradient.length - 1];
  }
  else {
    //find the two colors to interpolate
    let step = 1.0 / (gradient.length -1);
    let indexFirstColor = Math.floor(interpolation/step);
    let interpolationBetweenTwoColors = (interpolation - (indexFirstColor * step))  /  step;
    return getColor(gradient[indexFirstColor], gradient[indexFirstColor+1], interpolationBetweenTwoColors)
  }
}

function getPoint(point)
{
  function lonlatToPoint(x,y) {
    let pointCoordonates = ol.proj.transform([x, y], 'EPSG:4326','EPSG:900913');
    return new ol.geom.Point([pointCoordonates[0], pointCoordonates[1]]);
  }

  // let gradient= [
  //   {r: 255  ,g:255 , b: 0  },
  //   {r: 255  ,g:128 , b: 0  },
  //   {r: 255  ,g:0 , b: 0  }
  // ];
  let gradient= []
  let colors = document.getElementById("legendColors").children;
  for (let i = 0, length = colors.length; i < length; i++) {
    gradient.push(
      {
         r: parseInt(colors[i].getAttribute('data-red')),
         g:parseInt(colors[i].getAttribute('data-green')),
         b: parseInt(colors[i].getAttribute('data-blue'))
      });
	 }

  let circleColor = getColorFromGradient(gradient,point['interpolation']);

  let circleStyle = new ol.style.Style({
    image: new ol.style.Circle({
        radius: 6,
        fill: new ol.style.Fill({
            color: `rgba(${circleColor.r},${circleColor.g},${circleColor.b},0.9)`
        })
  })});

  let p = new ol.Feature({
    'geometry': lonlatToPoint(point['lon'],point['lat']),
    'value' : point['interpolation'],
    'unormalizedValue' : point['value'],
    'unit' : point['unit']
  });
  p.setStyle(circleStyle);
  return p;
}

function updateVisualizationLayer(points)
{
  if(olVisualizationLayer)
  {
    olMap.removeLayer(olVisualizationLayer);
  }

  let features = new Array(points.length);
  for(let i = 0; i < points.length; ++i)
  {
    features[i] = getPoint(points[i]);
  }

  let pointsSource = new ol.source.Vector({
    features: features,
  });

  let visualizationLayer = new ol.layer.Vector({
    source: pointsSource
  });
  olVisualizationLayer = visualizationLayer; //keep access to map variable
  olMap.addLayer(olVisualizationLayer);

}
